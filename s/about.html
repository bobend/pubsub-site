<!DOCTYPE html> 
<html> 
	<head> 
		<title>pubsub.io - about</title> 
		<link href='http://fonts.googleapis.com/css?family=Monofett' rel='stylesheet' type='text/css'>		
		<link href="/s/reset.css" rel="stylesheet" type="text/css">
		<link href="/s/style.css" rel="stylesheet" type="text/css">
		<style> 			
			#main {
				margin: auto;
				width: 610px;
				left: 300px;
				position: absolute;
			}
			#nav {
				position: absolute;
				top: 170px;
				left: 25px;
			}
			#nav a {
				display: block;
				margin-bottom: 15px;
			}
			#by {
				padding-top: 30px;
			}
			#by a {
				font-size: 15px;
			}
			a {
				font-size: 20px;
				text-decoration: none;
			}
			p a {
				font-size: 16px;
				text-decoration: none;
			}
			p {
				margin-bottom: 5px;
				text-align: left;
				color: #FFFFFF;
				margin-bottom: 25px;
				line-height: 25px;
			}
		</style>
	</head> 
	<body> 
		<div id='nav'>
			<a href='/about'>about</a>
			<a href='/docs'>documentation</a>
			<a href='/slides'>slides</a>
			<a href='https://github.com/pubsubio'>github</a>
			<div id='by'>
				<a href='http://twitter.com/ianjorgensen'>@ianjorgensen</a>
				<a href='http://twitter.com/mafintosh'>@mafintosh</a>
			</div>
		</div>
		<div id='main'>
			<div class='logo'>PUBSUB.IO</div>
			<h2 class='sub-text'>the story</h2> 
			<p>Pubsub.io is an attempt to change the way we publish and consume live data. It attempts to do so by focusing on the data.</p>
			<h2 class='sub-text'>not channels</h2> 
			<p>When you think of a publish subscribe system you immediately think of channels, meaning that you publish and subscribe to data on channel. Maybe this is modeled after sockets or maybe its an analog to the radio spectrum and its frequencies, it really doesn't matter, the only thing that matters here is that its limiting.</p>
				<p>Channels get the data across to the other side, they achieve this by strongly coupling the sender and the receiver. They need to have a agreement about the data, its size, format, contents, frequency, etc. A data stream that might be appropriate to a desktop client might be useless to a slim mobile client that might need a fraction of the data at more forgivable intervals. In short, data transmitted over a channel is <strong>difficult to repurpose</strong>. Another issue is that <strong>data lives across channels</strong>. To address this issue, patterns emerge on top of the channels, plus you need to deal with a ever growing number of channels, e.g. when you put your users id in the channel. Systems try to remedy this by allowing wildcard or pattern matching on channel names, this patches the immediate problem, you might argue that its a hack. They are encoding state into the channel name, and doing string matching to match the states they need. Another issue is authentication, all data transmitted over a channel shares the same level of permission. You cant granulate your authentication without creating new channels.</p>
			<h2 class='sub-text'>queries</h2> 
				<p>Channels are by definition coupled. The idea for pubsub.io was inspired by how databases decrease coupling. A database provides a nice clean interface to your data, the interface to the data is the data itself. You might put data in buckets, i.e. tables or collection, but you always (albeit key-value stores) access the data by defining the data you want. You access the data though a query language. You can argue that since we started using databases we've hardly looked back. We separate our data from our code and access it though some sort of query language.</p>
			<h2 class='sub-text'>pubsub.io</h2> 
				<p>Pubsub.io adds the interface of a database to a publish subscribe system. In order to do this we needed to create a <a href='/docs'>query language</a> and a reverse query matcher. The reverse query matcher basically stores a collection of queries and matches incoming data against these. The <a href='/docs'>query language</a> is inspired by monogdb's query language. Data needs to be protected, as a provider (publisher) you want to know that you data is safe, but as a consumer (subscriber) you care about the datas intergrity. Authenitcation and verification are supported by the language. Unlike most, pubsub.io authenticates the data, by authenticating the data item's properties, not the connection, transport, or channel. We have even added experimental support for data specific queries, we currently support advanced date time and very simple geo queries.</p>
				<p>If you need a pipe, don't use pubsub.io, granted you could use it and it would work just as well as any other pipe, but its more than that, and you should use it as more. Pubsub.io is not for everybody. Some problems are better solved by key-value stores than with RDBMS databases, the same principle applies to pubsub.io.</p>
			<h2 class='sub-text'>future</h2> 
				<p>Pubsub.io is written 100% in nodejs, but its meant to be used by any platform. Live clients currently exist for the browser and nodejs. The system is not meant to be one transport only, we currently support non live transports, thorough web hooks. We've even added a http publish interface, so anybody can publish to pubsub.io. In the near future we will be working on adding more fallback mechanisms to the transport layer, adding support for clustering, dynamically indexing the queries as they come in, creating sample applications, improving the documentation, documenting the protocol, building more client libraries, ...</p>
			<h2 class='sub-text'>help</h2> 
				<p>Its still early days and as you can see there is lots left to do. So if you'd like to help, any of the above you be a great <a href='https://github.com/pubsubio/'>place to start</a></p>
		</div>
		<script src='/s/sh.js'></script>
		<script type="text/javascript">

		  var _gaq = _gaq || [];
		  _gaq.push(['_setAccount', 'UA-24599059-1']);
		  _gaq.push(['_trackPageview']);

		  (function() {
		    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
		    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
		    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
		  })();

		</script>
	</body> 
</html>